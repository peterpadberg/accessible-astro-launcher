---
/**
 * Launcher Component
 *
 * @description An accessible command palette/launcher dialog with keyboard navigation and search.
 * Uses semantic HTML with proper ARIA patterns: role="switch" for toggles, native anchors for links.
 * Focus stays on the search input while aria-activedescendant manages the active item announcement.
 * This allows continuous typing while navigating with arrow keys.
 * Supports multiple triggers via the LauncherTrigger component's launcherId prop.
 */

interface Labels {
  placeholder?: string
  noResults?: string
  resultsCount?: string
  endOfResults?: string
  close?: string
  clear?: string
  toSelect?: string
  toNavigate?: string
  toClose?: string
  searchHint?: string
}

interface Props {
  /**
   * Unique identifier for this launcher (must match launcherId on LauncherTrigger components)
   */
  id: string
  /**
   * i18n labels for the launcher UI
   */
  labels?: Labels
  /**
   * Additional classes to apply to the dialog
   */
  class?: string
  /**
   * HTML attributes to spread on the dialog
   */
  [key: string]: string | Labels | boolean | undefined
}

const { id, labels = {}, class: className, ...rest } = Astro.props

const {
  placeholder = 'Type to search...',
  noResults = 'No results for "{query}"',
  endOfResults = "You've reached the end of the results",
  resultsCount = '{count} results for "{query}"',
  close = 'Close',
  clear = 'Clear',
  toSelect = 'Select',
  toNavigate = 'Navigate',
  toClose = 'Close',
  searchHint = 'Type to filter results. Use arrow keys to navigate, Enter to select.',
} = labels

// Generate unique IDs for internal elements
const inputId = `${id}-input`
const resultsId = `${id}-results`
const titleId = `${id}-title`
const statusId = `${id}-status`
const hintId = `${id}-hint`
---

<dialog
  id={id}
  class:list={['launcher', className]}
  aria-labelledby={titleId}
  aria-modal="true"
  {...rest}
>
  <div class="wrapper">
    <div class="header">
      <h2 id={titleId} class="sr-only">Launcher</h2>
      <search class="search">
        <label for={inputId} class="sr-only">{placeholder}</label>
        <input
          type="search"
          id={inputId}
          class="input"
          placeholder={placeholder}
          aria-describedby={hintId}
          aria-controls={resultsId}
          aria-activedescendant=""
          autocomplete="off"
          spellcheck="false"
        />
        <button type="button" class="clear" hidden>{clear}</button>
      </search>
      <button type="button" class="close">{close}</button>
    </div>

    <div class="content" tabindex="-1">
      <p id={hintId} class="sr-only">
        {searchHint}
      </p>
      <div id={statusId} class="sr-only" role="status" data-template={resultsCount}></div>
      <div class="results" id={resultsId}>
        <slot />
        <p class="end-of-results">{endOfResults}</p>
      </div>
      <div class="no-results" hidden data-template={noResults}>
        <p>{noResults}</p>
      </div>
    </div>

    <div class="footer">
      <div class="visual">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="var(--launcher-subtle-text-color)"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
          aria-hidden="true"
        >
          <path
            d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"
          ></path>
        </svg>
      </div>
      <div class="hints">
        <div class="hint">
          <span>{toSelect}</span>
          <kbd>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              aria-hidden="true"
            >
              <path d="M20 4v7a4 4 0 0 1-4 4H4"></path>
              <path d="m9 10-5 5 5 5"></path>
            </svg>
            <span class="sr-only">Enter</span>
          </kbd>
        </div>
        <div class="hint-separator"></div>
        <div class="hint">
          <span>{toNavigate}</span>
          <kbd>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              aria-hidden="true"
            >
              <path d="M12 5v14"></path>
              <path d="m19 12-7 7-7-7"></path>
            </svg>
            <span class="sr-only">Arrow down</span>
          </kbd>
          <kbd aria-label="Arrow up">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="12"
              height="12"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              aria-hidden="true"
            >
              <path d="m5 12 7-7 7 7"></path>
              <path d="M12 19V5"></path>
            </svg>
            <span class="sr-only">Arrow up</span>
          </kbd>
        </div>
        <div class="hint-separator"></div>
        <div class="hint">
          <span>{toClose}</span>
          <kbd>Esc</kbd>
        </div>
      </div>
    </div>
  </div>
</dialog>

<script>
  /**
   * Interface for launcher items (switches and links)
   */
  interface LauncherItemData {
    element: HTMLAnchorElement | HTMLButtonElement
    wrapper: HTMLElement
    label: string
    keywords: string[]
    type: 'switch' | 'link'
    href?: string
    action?: string
  }

  /**
   * Store abort controllers for cleanup
   */
  let keydownController: AbortController | undefined
  let clickController: AbortController | undefined

  /**
   * Track which trigger opened the dialog for focus restoration
   */
  const activeTriggers = new Map<HTMLDialogElement, HTMLButtonElement | null>()

  /**
   * Detect the operating system for keyboard shortcut activation
   */
  const detectOS = (): 'mac' | 'windows' | 'other' => {
    const userAgent = navigator.userAgent.toLowerCase()

    if (userAgent.includes('mac')) return 'mac'
    if (userAgent.includes('win')) return 'windows'
    return 'other'
  }

  /**
   * Get all launcher items from the dialog (both switches and links)
   */
  const getItems = (dialog: HTMLDialogElement): LauncherItemData[] => {
    const switches = dialog.querySelectorAll<HTMLButtonElement>('.launcher-switch')
    const links = dialog.querySelectorAll<HTMLAnchorElement>('.launcher-link')

    const switchItems: LauncherItemData[] = Array.from(switches).map((element) => ({
      element,
      wrapper: element.closest('.launcher-switch-wrapper') as HTMLElement,
      label: element.dataset.label || '',
      keywords: element.dataset.keywords?.split(',').filter(Boolean) || [],
      type: 'switch' as const,
      action: element.dataset.action,
    }))

    const linkItems: LauncherItemData[] = Array.from(links).map((element) => ({
      element,
      wrapper: element.closest('.launcher-link-wrapper') as HTMLElement,
      label: element.dataset.label || '',
      keywords: element.dataset.keywords?.split(',').filter(Boolean) || [],
      type: 'link' as const,
      href: element.dataset.href,
    }))

    // Return items in DOM order
    const allElements = dialog.querySelectorAll<HTMLElement>('.launcher-switch, .launcher-link')
    return Array.from(allElements).map((el) => {
      if (el.classList.contains('launcher-switch')) {
        return switchItems.find((item) => item.element === el)!
      }
      return linkItems.find((item) => item.element === el)!
    })
  }

  /**
   * Get visible (not hidden) items
   */
  const getVisibleItems = (dialog: HTMLDialogElement): LauncherItemData[] => {
    return getItems(dialog).filter((item) => item.wrapper && !item.wrapper.hidden)
  }

  /**
   * Simple fuzzy search matching
   */
  const matchesSearch = (item: LauncherItemData, query: string): boolean => {
    const searchTerms = query.toLowerCase().split(/\s+/)
    const searchableText = [item.label, ...item.keywords].join(' ').toLowerCase()

    return searchTerms.every((term) => searchableText.includes(term))
  }

  /**
   * Update the status element for screen readers
   */
  const updateStatus = (dialog: HTMLDialogElement, count: number, query: string): void => {
    const statusElement = dialog.querySelector<HTMLElement>('[role="status"]')
    if (!statusElement) return

    const template = statusElement.dataset.template || '{count} results for "{query}"'
    statusElement.textContent = template.replace('{count}', String(count)).replace('{query}', query)
  }

  /**
   * Filter items based on search query
   */
  const filterItems = (dialog: HTMLDialogElement, query: string): void => {
    const items = getItems(dialog)
    const noResultsElement = dialog.querySelector<HTMLElement>('.no-results')
    const noResultsText = noResultsElement?.querySelector<HTMLElement>('p')
    const groups = dialog.querySelectorAll<HTMLElement>('.launcher-preferences, .launcher-nav')
    const endOfResultsElement = dialog.querySelector<HTMLElement>('.end-of-results')

    let visibleCount = 0

    items.forEach((item) => {
      const matches = !query || matchesSearch(item, query)

      if (item.wrapper) {
        item.wrapper.hidden = !matches
      }
      if (matches) visibleCount++
    })

    const hasVisibleItems = visibleCount > 0

    // Hide empty groups
    groups.forEach((group) => {
      const visibleItems = group.querySelectorAll(
        '.launcher-switch-wrapper:not([hidden]), .launcher-link-wrapper:not([hidden])'
      )
      group.hidden = visibleItems.length === 0
    })

    // Show/hide no results message and update text with query
    if (noResultsElement) {
      noResultsElement.hidden = hasVisibleItems
      // Update the no results text to include the query
      if (noResultsText && query) {
        const template = noResultsElement.dataset.template || 'No results for "{query}"'
        noResultsText.textContent = template.replace('{query}', query)
      }
    }

    // Show/hide end of results message
    if (endOfResultsElement) {
      endOfResultsElement.hidden = !hasVisibleItems
    }

    // Announce results count to screen readers (including 0 results)
    if (query) {
      updateStatus(dialog, visibleCount, query)
    }

    // Reset active item to first visible item
    const visibleItems = getVisibleItems(dialog)
    if (visibleItems.length > 0) {
      setActiveItem(dialog, visibleItems[0].element)
    } else {
      clearActiveItem(dialog)
    }
  }

  /**
   * Set the active item using aria-activedescendant
   * Focus stays on the input, but the item is visually and semantically highlighted
   */
  const setActiveItem = (
    dialog: HTMLDialogElement,
    item: HTMLAnchorElement | HTMLButtonElement
  ): void => {
    const input = dialog.querySelector<HTMLInputElement>('.input')

    // Clear active state from all items
    dialog.querySelectorAll('.launcher-switch, .launcher-link').forEach((element) => {
      element.removeAttribute('data-active')
    })

    // Set active state on the item
    item.setAttribute('data-active', 'true')

    // Update aria-activedescendant on the input
    if (input && item.id) {
      input.setAttribute('aria-activedescendant', item.id)
    }

    // Scroll item into view
    item.scrollIntoView({ block: 'nearest' })
  }

  /**
   * Clear the active item state
   */
  const clearActiveItem = (dialog: HTMLDialogElement): void => {
    const input = dialog.querySelector<HTMLInputElement>('.input')

    dialog.querySelectorAll('.launcher-switch, .launcher-link').forEach((element) => {
      element.removeAttribute('data-active')
    })

    if (input) {
      input.setAttribute('aria-activedescendant', '')
    }
  }

  /**
   * Get the currently active item
   */
  const getCurrentItem = (dialog: HTMLDialogElement): HTMLElement | null => {
    return dialog.querySelector('.launcher-switch[data-active], .launcher-link[data-active]')
  }

  /**
   * Navigate to previous/next item
   * Focus stays on input, only aria-activedescendant changes
   */
  const navigateItems = (dialog: HTMLDialogElement, direction: 'up' | 'down'): void => {
    const visibleItems = getVisibleItems(dialog)
    if (visibleItems.length === 0) return

    const currentItem = getCurrentItem(dialog)
    const currentIndex = currentItem
      ? visibleItems.findIndex((item) => item.element === currentItem)
      : -1

    let nextIndex: number
    if (direction === 'down') {
      nextIndex = currentIndex < visibleItems.length - 1 ? currentIndex + 1 : 0
    } else {
      nextIndex = currentIndex > 0 ? currentIndex - 1 : visibleItems.length - 1
    }

    setActiveItem(dialog, visibleItems[nextIndex].element)
  }

  /**
   * Activate the currently focused item
   */
  const activateCurrentItem = (dialog: HTMLDialogElement): void => {
    const currentItem = getCurrentItem(dialog) as HTMLAnchorElement | HTMLButtonElement | null
    if (!currentItem) return

    const isSwitch = currentItem.classList.contains('launcher-switch')
    const isLink = currentItem.classList.contains('launcher-link')

    if (isSwitch) {
      const action = currentItem.dataset.action
      if (action) {
        // Keep the launcher open for preference toggles so users can change multiple settings
        document.dispatchEvent(
          new CustomEvent('launcher:action', {
            detail: { action },
          })
        )
      }
    } else if (isLink) {
      const href = currentItem.dataset.href || currentItem.getAttribute('href')
      if (href) {
        closeLauncher(dialog)
        window.location.href = href
      }
    }
  }

  /**
   * Open the launcher dialog
   */
  const openLauncher = (dialog: HTMLDialogElement, trigger?: HTMLButtonElement): void => {
    const input = dialog.querySelector<HTMLInputElement>('.input')
    const clearBtn = dialog.querySelector<HTMLButtonElement>('.clear')

    // Store the trigger that opened the dialog for focus restoration on close
    activeTriggers.set(dialog, trigger || null)

    dialog.showModal()

    // Dispatch open event for preference state sync
    document.dispatchEvent(new CustomEvent('launcher:open'))

    // Focus input
    if (input) {
      input.value = ''
      input.focus()
    }

    if (clearBtn) {
      clearBtn.hidden = true
    }

    // Reset filter and set first item as focusable
    filterItems(dialog, '')

    // Set up event listeners
    keydownController = new AbortController()
    clickController = new AbortController()

    // Handle keyboard navigation
    // Focus stays on input, arrow keys change aria-activedescendant
    document.addEventListener(
      'keydown',
      (event) => {
        if (event.key === 'ArrowDown') {
          event.preventDefault()
          navigateItems(dialog, 'down')
        } else if (event.key === 'ArrowUp') {
          event.preventDefault()
          navigateItems(dialog, 'up')
        } else if (event.key === 'Enter') {
          const currentItem = getCurrentItem(dialog)
          if (currentItem) {
            event.preventDefault()
            activateCurrentItem(dialog)
          }
        }
      },
      { signal: keydownController.signal }
    )

    // Handle backdrop click
    dialog.addEventListener(
      'click',
      (event) => {
        if (event.target === dialog) {
          closeLauncher(dialog)
        }
      },
      { signal: clickController.signal }
    )
  }

  /**
   * Close the launcher dialog
   */
  const closeLauncher = (dialog: HTMLDialogElement): void => {
    // Get the trigger that opened this dialog
    const trigger = activeTriggers.get(dialog)

    dialog.close()

    // Return focus to the trigger that opened the dialog
    if (trigger) {
      trigger.focus({ preventScroll: true })
    }

    // Clean up
    activeTriggers.delete(dialog)
    keydownController?.abort()
    clickController?.abort()
  }

  /**
   * Initialize a launcher instance
   */
  const initLauncher = (dialog: HTMLDialogElement): void => {
    const launcherId = dialog.id

    // Find all triggers that target this launcher
    const triggers = document.querySelectorAll<HTMLButtonElement>(
      `[data-launcher-target="${launcherId}"]`
    )
    const input = dialog.querySelector<HTMLInputElement>('.input')
    const closeBtn = dialog.querySelector<HTMLButtonElement>('.close')
    const clearBtn = dialog.querySelector<HTMLButtonElement>('.clear')
    const os = detectOS()

    if (triggers.length === 0) {
      console.warn(`Launcher: No trigger elements found for launcher #${launcherId}`)
      return
    }

    // Open on trigger click (supports multiple triggers)
    triggers.forEach((trigger) => {
      trigger.addEventListener('click', () => openLauncher(dialog, trigger))
    })

    // Global keyboard shortcut (CMD/CTRL + K)
    document.addEventListener('keydown', (event) => {
      const isMac = os === 'mac'
      const modifier = isMac ? event.metaKey : event.ctrlKey

      if (modifier && event.key.toLowerCase() === 'k') {
        event.preventDefault()

        if (dialog.open) {
          closeLauncher(dialog)
        } else {
          // When opened via keyboard, find the first visible trigger
          const visibleTrigger = Array.from(triggers).find((t) => {
            const style = window.getComputedStyle(t)
            return style.display !== 'none' && style.visibility !== 'hidden'
          })
          openLauncher(dialog, visibleTrigger)
        }
      }
    })

    // Close button
    closeBtn?.addEventListener('click', () => closeLauncher(dialog))

    // Handle escape key (native dialog behavior, but we want to clean up)
    dialog.addEventListener('close', () => {
      if (input) {
        input.value = ''
      }

      if (clearBtn) {
        clearBtn.hidden = true
      }

      filterItems(dialog, '')
      keydownController?.abort()
      clickController?.abort()
    })

    // Search input with debounce for performance
    let debounceTimer: ReturnType<typeof setTimeout>
    input?.addEventListener('input', (event) => {
      const query = (event.target as HTMLInputElement).value

      // Toggle clear button immediately
      if (clearBtn) {
        clearBtn.hidden = !query
      }

      // Debounce the filtering for better performance with many items
      clearTimeout(debounceTimer)
      debounceTimer = setTimeout(() => {
        filterItems(dialog, query)
      }, 16) // ~1 frame, feels instant but batches rapid keystrokes
    })

    // Clear button
    clearBtn?.addEventListener('click', () => {
      if (input) {
        input.value = ''
        input.focus()
        filterItems(dialog, '')
        clearBtn.hidden = true
      }
    })

    // Handle item clicks
    dialog.addEventListener('click', (event) => {
      const target = event.target as HTMLElement
      const switchEl = target.closest<HTMLButtonElement>('.launcher-switch')
      const linkEl = target.closest<HTMLAnchorElement>('.launcher-link')

      if (switchEl) {
        const action = switchEl.dataset.action
        if (action) {
          // Keep the launcher open for preference toggles so users can change multiple settings
          document.dispatchEvent(
            new CustomEvent('launcher:action', {
              detail: { action },
            })
          )
        }
      } else if (linkEl) {
        // Let native link behavior work, just close the dialog
        closeLauncher(dialog)
      }
    })

    // Handle item hover - track pointer position to ignore scroll-under-pointer
    let lastPointerX = -1
    let lastPointerY = -1

    dialog.addEventListener('pointermove', (event) => {
      // Only respond if pointer actually moved (not content scrolling under it)
      if (event.clientX === lastPointerX && event.clientY === lastPointerY) return
      lastPointerX = event.clientX
      lastPointerY = event.clientY

      const target = event.target as HTMLElement
      const item = target.closest<HTMLAnchorElement | HTMLButtonElement>(
        '.launcher-switch, .launcher-link'
      )
      const wrapper = item?.closest<HTMLElement>('.launcher-switch-wrapper, .launcher-link-wrapper')

      if (item && wrapper && !wrapper.hidden) {
        setActiveItem(dialog, item)
      }
    })
  }

  // Initialize all launchers
  const initAllLaunchers = (): void => {
    const dialogs = document.querySelectorAll<HTMLDialogElement>('.launcher')
    dialogs.forEach(initLauncher)
  }

  // Run on load
  initAllLaunchers()

  // Re-initialize after Astro view transitions
  document.addEventListener('astro:after-swap', initAllLaunchers)
</script>

<style>
  :where(.launcher) {
    backdrop-filter: blur(40px);
    margin: auto;
    margin-block-start: 15vh;
    box-shadow: var(--launcher-shadow);
    border: 1px solid var(--launcher-outer-border-color);
    border-radius: var(--launcher-radius-md);
    background-color: var(--launcher-main-body-color);
    padding: 0;
    inline-size: var(--launcher-width);
    block-size: var(--launcher-height);
    overflow: hidden;
    font-family: inherit;
  }

  :where(.launcher[open]) {
    display: flex;
    flex-direction: column;
  }

  :where(.launcher)::backdrop {
    backdrop-filter: blur(4px);
    background-color: var(--launcher-backdrop-color);
  }

  :where(.wrapper) {
    display: flex;
    position: relative;
    flex: 1;
    flex-direction: column;
    border: 1px solid var(--launcher-inner-border-color);
    border-radius: calc(var(--launcher-radius-md) - 1px);
    min-block-size: 0;
    overflow: hidden;
  }

  :where(.header) {
    display: flex;
    align-items: center;
    gap: var(--launcher-space-lg);
    box-shadow: var(--launcher-header-shadow);
    border-block-end: 1px solid var(--launcher-inner-border-color);
    padding: var(--launcher-space-md);
  }

  :where(.search) {
    position: relative;
    flex: 1;
  }

  :where(.input) {
    border: none;
    border-radius: var(--launcher-radius-md);
    background-color: transparent;
    inline-size: 100%;
    color: var(--launcher-subtle-text-color);
    font-size: var(--launcher-font-size-lg);
    line-height: var(--launcher-line-height);
    font-family: inherit;
  }

  :where(.input)::placeholder {
    color: var(--launcher-subtle-text-color);
  }

  :where(.input:focus),
  :where(.input:focus-visible) {
    outline: none;
    box-shadow: none;
  }

  :where(.clear) {
    display: flex;
    position: absolute;
    justify-content: center;
    align-items: center;
    transition: color var(--launcher-animation-duration) var(--launcher-animation-timing);
    cursor: pointer;
    inset-block: 0;
    inset-inline-end: 0;
    border: none;
    border-radius: var(--launcher-radius-sm);
    background-color: transparent;
    padding: 0;
    color: var(--launcher-subtle-text-color);
    font-size: var(--launcher-font-size-sm);
  }

  :where(.clear:hover),
  :where(.clear:focus-visible) {
    color: var(--launcher-text-color);
  }

  :where(.close) {
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px solid var(--launcher-inner-border-color);
    border-radius: var(--launcher-radius-md);
    background-color: transparent;
    padding: var(--launcher-space-xs);
    color: var(--launcher-subtle-text-color);
    font-size: var(--launcher-font-size-sm);
  }

  :where(.close:hover),
  :where(.close:focus-visible) {
    background-color: var(--launcher-interaction-color);
    color: var(--launcher-text-color);
  }

  :where(.content) {
    flex: 1;
    min-block-size: 0;
    overflow-y: auto;
    overscroll-behavior: contain;
    scroll-behavior: smooth;
    scrollbar-width: thin;
  }

  :where(.end-of-results) {
    margin-block: var(--launcher-space-lg);
    padding: var(--launcher-space-lg);
    color: var(--launcher-subtle-text-color);
    font-size: var(--launcher-font-size-sm);
    text-align: center;
  }

  :where(.no-results) {
    margin-block-start: calc(var(--launcher-space-lg) * 3);
    padding: var(--launcher-space-lg);
    color: var(--launcher-subtle-text-color);
    text-align: center;
  }

  :where(.footer) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: var(--launcher-space-md);
    border-block-start: 1px solid var(--launcher-inner-border-color);
    background-color: var(--launcher-action-bar-color);
    padding: var(--launcher-space-sm) var(--launcher-space-md);
  }

  :where(.visual) {
    opacity: 0.75;
  }

  :where(.hints) {
    display: flex;
    align-items: center;
    gap: var(--launcher-space-md);
  }

  :where(.hint) {
    display: flex;
    align-items: center;
    gap: var(--launcher-space-xs);
    opacity: 0.75;
    color: var(--launcher-subtle-text-color);
    font-weight: 500;
    font-size: var(--launcher-font-size-md);
  }

  :where(.hint-separator) {
    background-color: var(--launcher-inner-border-color);
    inline-size: 1px;
    block-size: 14px;
  }

  :global(body:has(.launcher[open])) {
    overflow: visible;
  }
</style>
